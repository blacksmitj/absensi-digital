// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// =============== ENUMS (minimal dulu) ===============
enum Role {
  OWNER
  ADMIN
  SUPERVISOR
  STAFF
}

enum WorkspaceStatus {
  ACTIVE
  INACTIVE
  ARCHIVED
}

// =============== MODELS DASAR ===============
model User {
  id            String    @id @default(cuid())
  email         String    @unique
  emailVerified DateTime?
  name          String?
  image         String?

  // back-relation: workspaces created by this user
  createdWorkspaces Workspace[] @relation("WorkspaceCreator")

  // memberships to workspaces
  memberships Membership[]

  assignments       ActivityAssignment[] // staff assigned to activities
  assignedAsManager ActivityAssignment[] @relation("AssignedBy")

  accounts Account[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Workspace {
  id          String          @id @default(cuid())
  name        String
  status      WorkspaceStatus @default(ACTIVE)
  joinCode    String          @unique // permanent, valid only if ACTIVE
  defaultRole Role            @default(STAFF)
  startDate   DateTime?
  endDate     DateTime?

  // creator
  createdById String
  createdBy   User   @relation("WorkspaceCreator", fields: [createdById], references: [id])

  // ⬇️ relasi ke Activity
  activities Activity[]

  // relations
  memberships Membership[]

  // workspace
  participants Participant[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status])
  @@index([createdById])
}

model Membership {
  id          String @id @default(cuid())
  userId      String
  workspaceId String
  role        Role

  user      User      @relation(fields: [userId], references: [id])
  workspace Workspace @relation(fields: [workspaceId], references: [id])

  createdAt DateTime @default(now())

  @@unique([userId, workspaceId]) // one membership per workspace
  @@index([workspaceId, role])
}

// ========= ENUM TAMBAHAN (opsional, tapi berguna) =========
enum ActivityStatus {
  SCHEDULED
  ONGOING
  CLOSED
}

// ========= ✨ BARU: ACTIVITY =========
model Activity {
  id          String         @id @default(cuid())
  workspaceId String
  name        String
  location    String?
  startAt     DateTime
  endAt       DateTime
  status      ActivityStatus @default(SCHEDULED)

  // aturan presensi per-aktivitas (fleksibel via JSON)
  // contoh default (di app): { "graceIn": 10, "minDuration": 30, "requireOut": true }
  rules Json

  workspace Workspace @relation(fields: [workspaceId], references: [id])

  // chechpoint
  checkpoints Checkpoint[]

  attendances Attendance[]

  assignments ActivityAssignment[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // bantu mencegah duplikasi nama+waktu di workspace yang sama
  @@unique([workspaceId, name, startAt])
  @@index([workspaceId, startAt])
}

// ================= PARTICIPANT =================
model Participant {
  id         String  @id @default(cuid())
  externalId String? // optional external/student ID
  name       String
  email      String?
  phone      String?
  qrRef      String  @unique // unique QR reference (e.g., "ps_00123")

  workspaceId String
  workspace   Workspace @relation(fields: [workspaceId], references: [id])

  attendances Attendance[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Optional (aktifkan kalau mau externalId unik per workspace):
  @@unique([workspaceId, externalId])
  @@index([workspaceId])
  @@index([name])
  @@index([externalId])
}

// ======== CHECKPOINT (pos/titik scan per aktivitas) ========
model Checkpoint {
  id         String @id @default(cuid())
  activityId String
  name       String
  code       String // short code for scanner, e.g. "CLASS-A", "CANTEEN-1"

  activity Activity @relation(fields: [activityId], references: [id])

  attendances Attendance[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Unik per aktivitas: "CLASS-A" boleh ada di aktivitas lain tanpa konflik
  @@unique([activityId, code])
  @@index([activityId])
}

// ===== ENUMS TAMBAHAN =====
enum ScanType {
  IN
  OUT
}

enum AttendanceStatus {
  ACCEPTED
  REJECTED
}

// ===== MODEL BARU: ATTENDANCE =====
model Attendance {
  id            String           @id @default(cuid())
  participantId String
  activityId    String
  checkpointId  String?
  scanType      ScanType
  scannedAt     DateTime
  status        AttendanceStatus // ACCEPTED | REJECTED
  reason        String? // e.g. "DOUBLE_SCAN", "OUT_OF_WINDOW"
  requestId     String // idempotency key (unik per attempt)
  offline       Boolean          @default(false)

  participant Participant @relation(fields: [participantId], references: [id])
  activity    Activity    @relation(fields: [activityId], references: [id])
  checkpoint  Checkpoint? @relation(fields: [checkpointId], references: [id])

  // who performed the scan (link to assignment)
  staffAssignmentId String?
  staffAssignment   ActivityAssignment? @relation("ScanByAssignment", fields: [staffAssignmentId], references: [id])

  createdAt DateTime @default(now())

  @@unique([requestId])
  @@index([participantId, activityId])
  @@index([activityId, scannedAt])
  @@index([checkpointId])
  @@index([staffAssignmentId])
}

model ActivityAssignment {
  id           String   @id @default(cuid())
  activityId   String
  userId       String
  roleNote     String? // e.g. "scanner", "coordinator"
  assignedById String? // optional: who assigned
  assignedAt   DateTime @default(now())

  activity   Activity @relation(fields: [activityId], references: [id])
  user       User     @relation(fields: [userId], references: [id])
  assignedBy User?    @relation("AssignedBy", fields: [assignedById], references: [id])

  // back-relation to Attendance (who scanned)
  scans Attendance[] @relation("ScanByAssignment")

  @@unique([activityId, userId]) // a user cannot be assigned twice to the same activity
  @@index([userId])
}

model Account {
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([provider, providerAccountId])
}
